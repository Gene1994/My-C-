复合类型(compound type)是指基于其他类型定义的类型.
本章将两种:引用和指针

引用(reference)通过将声明符写成&d的形式来定义引用类型,d是声明的变量名
*****************************************************************************************************
引用必须被初始化
*****************************************************************************************************
int ival = 1024;
int &refVal = ival;  //refVal指向ival(是ival的另一个名字)
int &refVal2;     //报错:引用必须被初始化
引用即别名:引用并非对象,相反的,它只是为一个已经存在的对象所起的另外一个名字.

指针(pointer):是指向另外一种类型的复合类型.实现了对其他对象的间接访问.
与引用不同点:
1.指针本身是对象 允许对指针赋值和拷贝,在指针生命周期内可以先后指向不同对象
2.无须在定义时赋值,如果没有被初始化,则拥有一个不确定值.

声明符写成*d. d是变量名

指针存放某个对象的地址 如果想要获取该地址 使用取地址符(&):
int ival = 42;
int *p = &ival;  //p存放变量ival的地址 或者说p是指向变量ival的指针

声明语句中 指针的类型实际上被用于指定它所指向对象的类型,所以二者必须匹配

指针的值应该属于下列4种状态之一:
1.指向一个对象
2.指向紧邻对象所占空间的下一个位置
3.空指针
4.无效指针,上述情况外的其他值
试图拷贝或以其他方式访问无效指针都将引发错误,编译器不负责检查此类错误 这一点和试图使用未经初始化的变量是一样的.

*****************************************************************************************************
如果指针指向了一个对象 可以使用解引用符(*)来访问该对象:
int ival = 42;
int *p = &ival;   //p存放变量ival的地址 或者说p是指向变量ival的指针
cout << *p        //由符号*得到指针p所指的对象,输出42!!!!!
*****************************************************************************************************

&:取地址符/声明引用  !!
*:解引用符/声明指针  !!

空指针
建议初始化所有指针

到底是改变指针的值还是指针所指对象的值???
记住:赋值永远改变的是等号左侧的对象.
pi  = &ival;    //pi的值被改变,现在指向了ival
*pi = 0;        //ival的值被改变,指针pi并没有改变.

void*指针可以存放任意对象的地址.一个void*指针存放着一个地址,但是地址中是什么类型我们并不了解.

指针指向指针:指针是内存中的对象 拥有地址
指向指针的引用: 引用本身不是一个对象 因此不能定义指向引用的指针 但指针是对象 所以存在对指针的引用
int i = 42;
int *p; //p是一个指针
int *&r = p   //r是一个对指针p的引用

r = &i;   //将p指向i
*r = 0;   //将i的值改为0

*****************************************************************************************************
面对一个比较复杂的指针或引用声明时,从右向左阅读有助于弄清它的真实含义
离变量最近的符号对变量的类型有最直接的影响(因此r是一个引用),其余部分确定r引用的类型是什么,('*'说明引用的是一个指针),
最后基本数据类型说明r引用的是一个int指针
*****************************************************************************************************
