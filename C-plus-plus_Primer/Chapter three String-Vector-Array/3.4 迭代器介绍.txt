所有标准库容器都可以使用迭代器,但是只有少数几种才同时支持下标运算符.

迭代器都有名为begin和end的成员:end成员负责返回指向容器"尾元素下一位置"的迭代器,叫做尾后迭代器
如果迭代器为空,则begin和end返回的是同一个迭代器,都是尾后迭代器

迭代器运算符
*iter  返回迭代器iter所指元素的引用
iter -> mem 解引用iter并获取该元素名为mem的成员,等价于(*iter).mem
++iter 令iter指示容器的下一个元素
--iter 令iter指示容器的上一个元素

因为end返回的迭代器并不实际指示某个元素,所以并不能对其进行递增或解引用操作

    for(auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
        *it = toupper(*it);

****************************************************************************************************************
C++程序员习惯性的使用 !=,原因和他们更愿意使用迭代器而非下标的原因一样:因为这种编程风格再标准库提供的所有容器中都有效.
****************************************************************************************************************

迭代器运算
iter + n: 向前移动若干元素
iter - n: 向后移动若干元素
只要两个迭代器指向同一个容器中的元素或者尾元素的下一位置,就能将其相减,所得的结果是两个迭代器的距离.其类型名为difference_type的带符号整数


使用迭代器完成二分搜索:
//text必须是有序的
//beg和end表示我们的搜索范围
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg)/2;     //初始状态下的中间点
while (mid != end && *mid != sought)
{
    if (sought < *mid)
        end = mid;
    else
        beg = mid + 1;
    mid = beg + (end - beg)/2;
}
